#!/usr/bin/env gosh
;; Communicate to kahua application server
;; $Id: kahua.cgi.in,v 1.36.2.1 2006/05/17 14:04:16 bizenn Exp $

;; This cgi script is kicked by httpd and pass through the request
;; to one of kahua servers.

;; The server to connect is determined as follows:
;;
;;  1. If PATH_INFO is given, its first component is regarded as a
;;     app-server type, and the rest is used as a cgsid.  Query
;;     parameters are ignored.   If more than one app-servers of
;;     that type are running, the client can't specify which
;;     server it will connect.
;;  2. If "x-kahua-cgsid" query parameter is given, the cgsid is
;;     taken from it and the app-server worker id is extracted.
;;  3. Otherwise, just connect to the supervisor and let it decide
;;     which app-server to handle the request.

(add-load-path "##libdir##")

(use gauche.net)
(use gauche.charconv)
(use gauche.logger)
(use gauche.parameter)
(use srfi-1)
(use srfi-2)
(use srfi-13)
(use srfi-19)
(use www.cgi)
(use util.list)
(use rfc.cookie)
(use rfc.base64)
(use rfc.sha1)
(use text.tree)
(use text.html-lite)
(use kahua.gsid)
(use kahua.config)
(use kahua.developer)
(use file.util)
##ADDITIONAL_LIBS##

;; Change this if you're using non-default sockbase
(define *sockbase* "unix:##KAHUA_SOCKET_BASE##")
(define *tmpbase* "##localstatedir##/tmp/kahua-")

(define-constant *TERMINATION-SIGNALS* (sys-sigset-add! (make <sys-sigset>) SIGTERM SIGINT SIGHUP SIGPIPE))

;; Change this if you're using non-default log path
;;(log-open "/tmp/kahua-cgi.log" :prefix "~Y ~T ~P[~$]: ")
(log-open "##KAHUA_CGI_LOGPATH##/kahua-cgi.log" :prefix "~Y ~T ~P[~$]: ")

;; bridge name option, mainly to pass "~user" information
(define *bridge-option* "")

;; getting cgi meta-variables; first we try cgi-metavariables parameter,
;; then use getenv for fallback.
(define (get-meta name)
  (or (and-let* ((mv (cgi-metavariables))
                 (p  (assoc name mv)))
        (cadr p))
      (sys-getenv name)))

;; send standard metavariables to worker.
(define *metavariables*
  '("AUTH_TYPE"
    "CONTENT_LENGTH"
    "CONTENT_TYPE"
    "GATEWAY_INTERFACE"
    "HTTP_ACCEPT"
    "HTTP_ACCEPT_CHARSET"
    "HTTP_ACCEPT_ENCODING"
    "HTTP_ACCEPT_LANGUAGE"
    "HTTP_HOST"
    "HTTP_KEEP_ALIVE"
    "HTTP_USER_AGENT"
    "PATH_INFO"
    "PATH_TRANSLATED"
    "REMOTE_ADDR"
    "REMOTE_HOST"
    "REMOTE_IDENT"
    "REMOTE_USER"
    "REQUEST_METHOD"
    "SCRIPT_NAME"
    "SERVER_NAME"
    "SERVER_PORT"
    "SERVER_PROTOCOL"
    "SERVER_SOFTWARE"
    ))

(define (metavariable-alist)
  (filter-map (lambda (meta)
                (let1 meta-var (get-meta meta)
                  (and meta-var
                       (cons meta meta-var))))
              *metavariables*))

(define (kcv value)
  (ces-convert value "*jp" (gauche-character-encoding)))

(define *default-content-type*
  (let1 encoding (gauche-character-encoding)
    (if (eq? 'none encoding)
        '("content-type" "text/html; charset=euc-jp")
        `("content-type" ,(format "text/html; charset=~s" encoding)))))

(define (compose-reply header body)
  (let ((status (assoc-ref header "x-kahua-status"))
	(header (if (assoc-ref header "content-type")
                    header
		    (cons *default-content-type* header))))
    (if (and status (equal? (car status) "SPVR-ERROR"))
        (let1 error-contents (string-append "SPVR-ERROR: " (car body)) (cadr body)
          (log-format "~a" error-contents)
	  (cgi-error-page error-contents))
	(receive (state cont) (get-gsid-from-header header)
          (for-each (lambda (hdr) (set-header! (car hdr) (cadr hdr)))
		    (filter (lambda (hdr) (not (#/^x-kahua-/ (car hdr))))
			    header))
 	  (set-cookie!
           (construct-cookie-string
            `(("x-kahua-sgsid" ,state
               :path ,(or (*worker-uri*)
                       (sys-dirname
                        (or (get-meta "SCRIPT_NAME") "/")))))))
	  body))))

;; load kahua.conf with "user" argument when PATH_INFO has ~user component.
(define (load-user-config user-dir)
  ;; use default kahua conf file.
  (kahua-init #f :user (string-drop user-dir 1))
  (set! *bridge-option* (string-append "/" user-dir))
  (set! *sockbase* (ref (kahua-config) 'sockbase)))

;; retrieve PATH_INFO, with processing ~user component.
;; returns #f if there's no PATH_INFO.
(define (get-path-info)
  (and-let* ((p (get-meta "PATH_INFO"))
             (l (cdr (string-split p #\/))))
    (when (and (pair? l) (#/^~.+/ (car l)))
      (load-user-config (car l))
      (set! l (cdr l)))
    (and (pair? l)
         (not (equal? (car l) ""))
         (filter (compose not string-null?) l))))

;; determine dispatch destination.
;; returns: (worker-id worker-type cont-gsid path-info)
(define (dispatch-destination params)
  (let* ((path-info   (get-path-info))
         (cont-gsid   (or (cgi-get-parameter "x-kahua-cgsid" params)
                          (if (and path-info (pair? (cdr path-info)))
                            (cadr path-info)
                            #f)))
         (worker-type (and path-info (car path-info)))
         (worker-id   (and cont-gsid (gsid->worker-id cont-gsid)))
         )
    (values worker-id worker-type cont-gsid path-info)))

;; construct absolute uri for the server root.
;; note that we can only guess the protocol scheme.
(define (server-uri)
  (let ((scheme (if (get-meta "HTTPS") "https" "http"))
        (name   (or (get-meta "SERVER_NAME") "localhost"))
        (port   (or (x->integer (get-meta "SERVER_PORT")) 80)))
    (format "~a://~a~a"
            scheme name
            (if (or (and (string=? scheme "http")  (= port 80))
                    (and (string=? scheme "https") (= port 443)))
                 ""
                 #`":,port"))))

;; prepare headers and dispatch the request to the appropriate server,
;; then receives the reply and forward it to the client.
(define (send-reply param)
  (receive (worker-id worker-type cont-gsid path-info)
      (dispatch-destination param)
    (log-format "~s ~s ~s" worker-id worker-type cont-gsid)
    (let* ((state-gsid (cgi-get-parameter "x-kahua-sgsid" param))
           (remote-addr (get-meta "REMOTE_ADDR"))
           (header     (list*
                        `("x-kahua-bridge"
                          ,(string-append (get-meta "SCRIPT_NAME")
                                          *bridge-option*))
                        `("x-kahua-server-uri" ,(server-uri))
                        `("x-kahua-metavariables" ,(metavariable-alist))
                        (cond-list
                         ((*worker-uri*) `("x-kahua-worker-uri" ,(*worker-uri*)))
                         (worker-type `("x-kahua-worker" ,worker-type))
                         (state-gsid `("x-kahua-sgsid" ,state-gsid))
                         (cont-gsid  `("x-kahua-cgsid" ,cont-gsid))
                         (path-info  `("x-kahua-path-info" ,path-info))
                         (remote-addr `("remote-addr" ,remote-addr)))))
           (sockaddr   (worker-id->sockaddr worker-id *sockbase*))
           )
      (log-format "cgsid: ~a (~a)" cont-gsid remote-addr)
      (for-each (lambda (f)
		  (if (file-exists? f)
		      (sys-chmod f #o660)))
		(cgi-temporary-files))
      (call-with-client-socket (make-client-socket sockaddr)
        (lambda (in out)
          (guard
           (eo (#t (log-format "(send-reply): Write error")))
           (write header out) (newline out)
           (write param  out) (newline out)
           (flush out)
           (guard
            (ei (#t (log-format "(send-reply): Read error")))
            (let* ((header (read in))
                   (body   (read in)))
              (compose-reply header body))))))
      )))

;; class of http response representation.
;; provide control over output headers, set cookies, redirect.
(define-class <response> ()
  ((headers  :init-value '())
   (cookies  :init-value '())
   (location :init-value #f)))

(define-method set-header! ((self <response>) name value)
  (set! (ref self 'headers)
        (append
         (list (make-keyword name) value)
         (ref self 'headers))))

(define-method set-cookie! ((self <response>) cookie)
  (set! (ref self 'cookies)
        (append cookie (ref self 'cookies))))

(define-method set-redirect! ((self <response>) url)
  (set! (ref self 'location) url))

(define-method publish ((self <response>) body)
  (list (apply cgi-header
               :cookies  (ref self 'cookies)
               :location (ref self 'location)
               (ref self 'headers))
        body))

(define response (make-parameter #f))

(define *worker-uri* (make-parameter #f))

(define-method set-header! (name value)
  (set-header! (response) name value))

(define-method set-cookie! (cookie)
  (set-cookie! (response) cookie))

(define-method set-redirect! (url)
  (set-redirect! (response) url))

(define-method publish (body)
  (publish (response) body))

(define (analize-virtual-hosting)
  (let1 path-info (get-meta "PATH_INFO")
    (if (not path-info)
        (cgi-metavariables)

      (let loop ((paths (cdr (string-split path-info #\/)))
                 (path-info '())
                 (metavariables (cgi-metavariables)))
        (cond
         ;; finish
         ((null? paths) (cons (list "PATH_INFO"
                                    (string-join (reverse path-info) "/" 'prefix))
                              metavariables))

         ;; set virtual hosting
         ((#/--vh--(https?):([^:]*):(\d+)/ (car paths))
          => (lambda (m)
               (let1 idx (list-index (pa$ equal? "--") (cdr paths))
                 (*worker-uri*
                  (format "~a/"
                          (string-join (take (cdr paths) idx) "/" 'prefix)))
                 (loop (drop (cdr paths) (+ idx 1))
                       path-info
                       `(("HTTPS" ,(if (equal? "https" (m 1))
                                       "on" #f))
                         ("SERVER_NAME" ,(m 2))
                         ("SERVER_PORT" ,(m 3))
                         ,@metavariables)))))

         (else (loop (cdr paths)
                     (cons (car paths) path-info)
                     metavariables)))))))

;; publish html. provide ~user authentication.
(define (publisher params)
  (parameterize ((cgi-metavariables (analize-virtual-hosting)))
    (let* ((path-info (get-meta "PATH_INFO"))
           (p (cadr (string-split (if (or (not path-info) 
                                          (string-null? path-info)) 
                                      "/" path-info) #\/))))
      (publish
       ;; make a body.
       (if (#/^~.+/ p)
           (begin
             ;; ~user authentication
             (let ((name (string-drop p 1))
                   (passwd (or (cgi-get-parameter "kahua-passwd-plain"
                                                  params :default #f)
                               (base64-decode-string
                                (cgi-get-parameter "kahua-passwd"
                                                   params :default "")))))
               (if (kahua-check-developer name passwd)
                   (begin
                     ;; when login successed, set passwd to cookie.
                     (set-cookie!
                      (construct-cookie-string
                       `(("kahua-passwd" ,(base64-encode-string passwd)
                          :path ,(or (*worker-uri*)
                                     (sys-dirname
                                      (or (get-meta "SCRIPT_NAME") "/")))))))
                     (send-reply params))
                 (unauthorized-form)
                 ))
             )
         (send-reply params)
         ))
      )))

;; ~user login form.
;; when login failed, show this.
(define (unauthorized-form)
  `(,(html-doctype)
    ,(html:html
      (html:head (html:title "Unauthorized"))
      (html:body (html:h1 "Unauthorized")
                 (html:form :method "post"
                   (html:span "password")
                   (html:input :type "password" :name "kahua-passwd-plain")
                   (html:input :type "submit" :value "login"))))))

(define (main args)
  (define (output-handler sexp)
    (let1 sbody (cadr sexp)
      (case (car sbody)
	((file)
	 (write-tree (car sexp))
	 (call-with-input-file (cadr sbody)
	   (lambda (in)
	     (copy-port in (current-output-port))
	     (flush))))
	(else
	 (if (ces-equivalent? (gauche-character-encoding)
			      (cgi-output-character-encoding))
	     (write-tree sexp)
	     (with-output-conversion
		 (current-output-port)
	       (cut write-tree sexp)
	       :encoding (cgi-output-character-encoding)))))))
  (call/cc
   (lambda (bye)
     (define (cleanup) (for-each sys-unlink (cgi-temporary-files)))
     (define (finish-server sig)
       (log-format (sys-signal-name sig))
       (cleanup) (bye 0))
     (log-format "CGI start")
     (guard (e (else (log-format "error(ignored): ~a" e)))
       (set-signal-handler! *TERMINATION-SIGNALS* finish-server)
       ##CGIBEGIN##
       (parameterize ((response (make <response>)))
	 (cgi-main publisher
		   :merge-cookies #t
		   :on-error cgi-error-proc
		   :output-proc output-handler
		   :part-handlers `((#t file+name ,*tmpbase*))
		   ))
       ##CGIEND##
       )
     (cleanup)
     (log-format "CGI end")
     (bye 0))))

(define (get-error-string e)
  (call-with-output-string
   (cut with-error-to-port <> (cut report-error e))))

(define (cgi-error-page message)
  `(,(html-doctype)
    ,(html:html
      (html:head (html:title "Error"))
      (html:body
       (html:h1 "Error")
       (html:div
	(html:p (html-escape-string message)))))))

(define (cgi-error-proc e)
  (let ((errmsg (string-append "CGI Error: " (slot-ref e 'message)))
        (errdetail (get-error-string e)))
    (log-format "CGI error caught: ~a ~a" errmsg errdetail)
    `(,(cgi-header :status "503 Service Temporaly Unavailable")
      ,(cgi-error-page errmsg))))

;; local variables:
;; mode: scheme
;; end:
